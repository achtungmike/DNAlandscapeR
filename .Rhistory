# map to colors
breaks <- seq(min_z, max_z, length.out = 100)
cols <- palette(length(breaks) + 1)
hicmcol <- matrix(as.character(cut(hicregion, c(-Inf, breaks, Inf), labels = cols)), nrow = nrow(hicregion))
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum & y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else if(y == 20){ #upside down triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y - 0.5, y)
} else {
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
runApp()
packrat::init9)
packrat::snapshot9)
packrat::snapshot()
packrat::restore()
packrat::restore()
packrat::snapshot
packrat::snapshot()
packrat::snapshot()
packrat::restore9)
packrat::restore()
install.packages("gfortran")
install.packages("lgfortran")
install.packages("nlme")
packrat::init()
source("https://bioconductor.org/biocLite.R")
biocLite("limma")
biocLite("rtracklayer")
packrat::init()
install.packages("devtools")
devtools::install_github("aryeelab/diffloop")
library(diffloop)
shiny::runApp()
packrat::snapshot()
runApp()
library(tools)
library(shiny)
library(shinyBS)
library(shinythemes)
library(ggplot2)
library(GenomicRanges)
library(diffloop)
library(Sushi)
library(foreach)
library(rtracklayer)
library(DT)
library(grid)
library(readr)
library(bumphunter)
library(shinyFiles)
library(markdown)
library(knitr)
library(gsubfn)
library(RCurl)
library(Matrix)
library(dplyr)
library(edgeR)
library(rsconnect)
library(miniUI)
?diffloop::`diffloop-package`
runApp()
runApp()
i <- 5
chia_pet_samples <- list() #Tracks samples linking with i
chia_pet_objects <- c() #Tracks subsetted objects
j <- 1 #Index of subsetted objects vector
map_chia_pet.indices <- c() #maps i to order in vector of subsetted objects
mc <- 1 #max counts
one_anchor_samples <- list() #Tracks samples linking with i
file.conn <- dynamic.val$c.full[[i]]
g_h.c.full
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/MCF7_1-POL2.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
head(x)
sample <- names(dynamic.val$c.list)[i]
sample <- "dummy"
objReg <- removeSelfLoops(subsetRegion(x, dynamic.val$region))
chr1reg <- GRanges(seqnames=c("1"),ranges=IRanges(start=c(152583052),end=c(152614119)))
region <- chr1reg
objReg <- removeSelfLoops(subsetRegion(x, region))
oa <- try(one_anchor_samples[[which(map_chia_pet.indices == i)]], silent = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
region
region.bed <- import.bw(file, which = addchr(region))
g_h.m.bw.full
file <-  "http://s3.amazonaws.com/dnalandscaper/data/human/methylation/GM12878-wgbs.bw"
region.bed <- import.bw(file, which = addchr(region))
head(region.bed)
?tile
smoother <- 1000
region
tile <- tile(region, width = smoother)
head(tile)
str(tile)
?GRangesList
length(tile)
tile <- unlist(tile(region, width = smoother))
length(tile)
head(tile)
smoother
widths(tile)
width(tile)
?tile
?GRanges::tile
?GenomicRanges::tile
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(methyl.vals[sh])$score, qh, mean))
tile <- unlist(tile(region, width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(regions))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
values <- unname(ugly$bwvalues, force = TRUE)
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(region))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
values <- unname(ugly$bwvalues, force = TRUE)
values
head(region.bed)
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
dim(ugly)
length(values.t)
values.t
dim(values.t)
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(region))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
dim(ugly)
vNA
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
tile
region.bed <- tile
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
bumpplot <- recordPlot()
pos <- region.bedgraph$start
y <- region.bedgraph[,4]
cluster_id <- clusterMaker(chr=chrom, pos=pos, maxGap = 100)
smooth <- locfitByCluster(x=pos, y=y, cluster=cluster_id, bpSpan=50)
plot(pos, smooth$fitted, type="l", xaxt='n',bty = "n",xaxs="i",yaxs="i",main=sample,adj=0,ylab="")
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
# mtext(sample,side=2,line=2.5,cex=1,font=2)
if(shade) polygon(cbind(c(min(pos), pos, max(pos)), c(min(y), y, min(y))), border=NA, col="black")
plot.new()
?locfitByCluster
g_h.t.bw.full
file <- "http://s3.amazonaws.com/dnalandscaper/data/human/tracks/MCF7-CTCF.bw"
region.bed <- import.bw(file, which = addchr(region))
# smooth
if(smoother != 0){
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
region.bed <- tile
}
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
trackplot <- recordPlot()
plotBedgraph(region.bedgraph, chromchr, start, end,
main = sample, adj=0)
#mtext(ylab,side=2,line=2.5,cex=1,font=2)
axis(side=2,las=2,tcl=.2)
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
region.bed
tile[mcols(tile)$score != NA]
mcols(tile)$score
region.bed <- tile[!is.na(mcols(tile)$score)]
tile[!is.na(mcols(tile)$score)]
region.bed
region.bed <- import.bw(file, which = addchr(region))
# smooth
if(smoother != 0){
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
region.bed <- supressWarnings(tile[!is.na(mcols(tile)$score)])
}
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
if(log2) region.bedgraph$score <- log2(region.bedgraph$score)
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
trackplot <- recordPlot()
plotBedgraph(region.bedgraph, chromchr, start, end,
main = sample, adj=0)
#mtext(ylab,side=2,line=2.5,cex=1,font=2)
axis(side=2,las=2,tcl=.2)
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
runApp()
?supressWarnings
runApp()
runApp()
runApp()
runApp()
packrat::snapshot()
shiny::runApp()
runApp()
runApp()
# Main functions for plotting the various tracks. A brief overview follows.
runApp()
runApp()
runApp()
median(c(1,1,1,1))
max(c(1,1,1,2))
mean(c(1,1,1,2))
runApp()
runApp()
runApp()
runApp()
?selectInput
runApp()
runApp()
xx
x
g_h.c.full
file <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/K562_1-POL2.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
file.conn <- file
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
x
head(x)
region
chr1reg <- GRanges(seqnames=c("1"),ranges=IRanges(start=c(152583052),end=c(152614119)))
chr1reg <- GRanges(seqnames=c("1"),ranges=IRanges(start=c(12583052),end=c(152614119)))
region <- chr1reg
findOverlaps(region, dlo@anchors)@to
dlo <- x
findOverlaps(region, dlo@anchors)@to
length(dlo@interactions$left %in% g)
sum(dlo@interactions[,1] %in% g)
g <- findOverlaps(region, dlo@anchors)@to
sum(dlo@interactions[,1] %in% g)
length(dlo@interactions[,1] %in% g)
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
sum(cc)
head(cc)
length(cc)
head(dlo@interactions[cc,])
head(dlo@counts[cc,])
head(dlo@rowData[cc,])
head(dlo@counts)
?matrix
head(data.frame(dlo@counts)[cc,])
nc <- as.matrix(dlo@counts[cc,], ncol = 1)
nc
head(nc)
dim(dlo@counts)[2]
g <- findOverlaps(region, dlo@anchors)@to
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
nc <- as.matrix(dlo@counts[cc,], ncol = dim(dlo@counts)[2])
colnames(nc) <- colnames(dlo@counts)
head(nc)
runApp()
runApp()
chr1reg <- GRanges(seqnames=c("9"),ranges=IRanges(start=c(21912689),end=c(22216233)))
chr1reg
region <- chr1reg
head(x)
g_h.c.full
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/Jurkat_1-SMC1.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
.subsetRegion2.quick(x, region)
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/MCF7_1-POL2.rds"
.subsetRegion2.quick(x, region)
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/K562_1-POL2.rds"
.subsetRegion2.quick(x, region)
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/Primed_ESC_1-SMC1.rds"
.subsetRegion2.quick(x, region)
dlo <- x
head(dlo)
g <- findOverlaps(region, dlo@anchors)@to
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
sum(cc)
dlo@interactions[,1] %in% g
sum(dlo@interactions[,1] %in% g)
head(dlo)
str(g)
g <- findOverlaps(region, dlo@anchors)@to
str(g)
g
region
dlo@anchors
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/Primed_ESC_1-SMC1.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
dlo <- x
.subsetRegion2.quick(x, region)
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/Jurkat_1-SMC1.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
objReg <- .subsetRegion2.quick(x, region)
max(objReg@counts)
dim(objReg)
runApp()
g_h.c.full
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/MCF7_1-POL2.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
region <- GRanges(seqnames=c("9"),ranges=IRanges(start=c(21912689),end=c(22216233)))
dlo <- x
g <- findOverlaps(region, dlo@anchors)@to
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
nc <- as.matrix(dlo@counts[cc,], ncol = dim(dlo@counts)[2])
colnames(nc) <- colnames(dlo@counts)
slot(dlo, "interactions", check = TRUE) <- dlo@interactions[cc,]
slot(dlo, "counts", check = TRUE) <- nc
slot(dlo, "rowData", check = TRUE) <- dlo@rowData[cc,]
head(dlo
)
objReg <- .subsetRegion2.quick(x, region)
objReg
chrom <- as.character(seqnames(y))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(y))))
end <- as.integer(end(ranges(range(y))))
y <- region
chrom <- as.character(seqnames(y))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(y))))
end <- as.integer(end(ranges(range(y))))
res <- objReg@rowData
n <- dim(objReg@interactions)[1]  #number of interactions
# Setup colors for plotting
cs <- 0
if(!is.null(res$loop.type) & colorLoops){
cs <- res$loop.type
cs <- gsub("e-p", "red", cs)
cs <- gsub("p-p", "orange", cs)
cs <- gsub("e-e", "mediumpurple1", cs)
cs <- gsub("ctcf", "blue", cs)
cs <- gsub("none", "black", cs)
} else {
cs <- rep("black", n)
}
colorLoops = TRUE
res <- objReg@rowData
n <- dim(objReg@interactions)[1]  #number of interactions
# Setup colors for plotting
cs <- 0
if(!is.null(res$loop.type) & colorLoops){
cs <- res$loop.type
cs <- gsub("e-p", "red", cs)
cs <- gsub("p-p", "orange", cs)
cs <- gsub("e-e", "mediumpurple1", cs)
cs <- gsub("ctcf", "blue", cs)
cs <- gsub("none", "black", cs)
} else {
cs <- rep("black", n)
}
leftAnchor <- as.data.frame(objReg@anchors[objReg@interactions[,1]])[c(1, 2, 3)]
LA <- do.call("rbind", replicate(1, leftAnchor, simplify = FALSE))
rightAnchor <- as.data.frame(objReg@anchors[objReg@interactions[,2]])[c(1, 2, 3)]
RA <- do.call("rbind", replicate(1, rightAnchor, simplify = FALSE))
colnames(LA) <- c("chr_1", "start_1", "end_1")
colnames(RA) <- c("chr_2", "start_2", "end_2")
name <- rep(NA, n)
strand_1 <- rep(".", n * 1)
strand_2 <- rep(".", n * 1)
score <- matrix(objReg@counts, ncol = 1)
bedPE <- data.frame(LA, RA, name, score, strand_1, strand_2, sample)
w <- loopWidth(objReg)
h <- sqrt(w/max(w))
lwd <- 5 * (bedPE$score/max_counts)
objReg@interactions[,1]
objReg@interactions
str(objReg@interactions)
str(as.matrix(objReg@interactions))
str(matrix(objReg@interactions, ncol = 2))
runApp()
runApp()
runApp()
runApp()
g_h.c.full
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/MCF7_1-POL2.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
.subsetRegion.quick(x, region, nanchors = 2)
region
x <- dlo
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
do <- x
dlo <- x
g <- findOverlaps(region, dlo@anchors)@to
if(nanchors == 2) {
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
} else {
cc <- xor(dlo@interactions[,1] %in% g, dlo@interactions[,2] %in% g)
}
nanchors = 2
head(dlo)
g <- findOverlaps(region, dlo@anchors)@to
if(nanchors == 2) {
cc <- dlo@interactions[,1] %in% g & dlo@interactions[,2] %in% g
} else {
cc <- xor(dlo@interactions[,1] %in% g, dlo@interactions[,2] %in% g)
}
sum(cc)
ni <- as.matrix(dlo@interactions[cc,], ncol = 2)
colnames(ni) <- c("left", "right")
dlo@interactions[cc,]
length(dlo@interactions[cc,])
ni <- as.matrix(dlo@interactions[cc,], ncol = 2)
ni
matrix(dlo@interactions[cc,], ncol = 2)
runApp()
runApp()
.subsetRegion.quick <- function(loops, region, nanchors = 2) {
g <- findOverlaps(region, loops@anchors)@to
if(nanchors == 2) { cc <- loops@interactions[,1] %in% g & loops@interactions[,2] %in% g
} else { cc <- xor(loops@interactions[,1] %in% g, loops@interactions[,2] %in% g) }
ni <- matrix(loops@interactions[cc,], ncol = 2)
colnames(ni) <- c("left", "right")
nc <- matrix(loops@counts[cc,], ncol = dim(loops@counts)[2])
colnames(nc) <- colnames(loops@counts)
slot(loops, "interactions", check = TRUE) <- ni
slot(loops, "counts", check = TRUE) <- nc
slot(loops, "rowData", check = TRUE) <- loops@rowData[cc,]
return(loops)
}
runApp()
runApp()
