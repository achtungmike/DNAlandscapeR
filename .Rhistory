}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}}
}
chr1reg <- GRanges(seqnames=c("1"),ranges=IRanges(start=c(5083052),end=c(152614119)))
region <- chr1reg
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
if(grepl("amazonaws", base)){
file <- paste(base, sample, "-", chromchr, ".rds", sep = "")
hicdata <- readRDS(gzcon(url(file)))
} else {
hicdata <- readRDS(base)
}
# Hacked Sushi HiC Plot Function
palette <- SushiColors(6)
rows <- as.numeric(rownames(hicdata))
cols <- as.numeric(colnames(hicdata))
hicregion <- as.matrix(hicdata[which(rows >= start & rows <= end), which(cols >= start & cols <= end)])
# determine number of bins
nbins <- nrow(hicregion)
stepsize <- abs(start - end)/(2 * nbins)
max_z <- max(hicregion, na.rm = TRUE)
min_z <- min(hicregion[hicregion > 0], na.rm = TRUE)
# map to colors
breaks <- seq(min_z, max_z, length.out = 100)
cols <- palette(length(breaks) + 1)
hicmcol <- matrix(as.character(cut(hicregion, c(-Inf, breaks, Inf), labels = cols)), nrow = nrow(hicregion))
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y < 20){
if(colnum != rownum){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else { #triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum | y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else { #triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum | y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else { #triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum & y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else { #triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
# map to colors
breaks <- seq(min_z, max_z, length.out = 100)
cols <- palette(length(breaks) + 1)
hicmcol <- matrix(as.character(cut(hicregion, c(-Inf, breaks, Inf), labels = cols)), nrow = nrow(hicregion))
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum & y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else if(y == 20){ #upside down triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y - 0.5, y)
} else {
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
runApp()
chr9reg <- GRanges(seqnames=c("9"),ranges=IRanges(start=c(0129720),end=c(23277926)))
base
sample
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
if(grepl("amazonaws", base)){
file <- paste(base, sample, "-", chromchr, ".rds", sep = "")
hicdata <- readRDS(gzcon(url(file)))
} else {
hicdata <- readRDS(base)
}
# Hacked Sushi HiC Plot Function
palette <- SushiColors(6)
rows <- as.numeric(rownames(hicdata))
cols <- as.numeric(colnames(hicdata))
hicregion <- as.matrix(hicdata[which(rows >= start & rows <= end), which(cols >= start & cols <= end)])
# determine number of bins
nbins <- nrow(hicregion)
stepsize <- abs(start - end)/(2 * nbins)
max_z <- max(hicregion, na.rm = TRUE)
min_z <- min(hicregion[hicregion > 0], na.rm = TRUE)
# map to colors
breaks <- seq(min_z, max_z, length.out = 100)
cols <- palette(length(breaks) + 1)
hicmcol <- matrix(as.character(cut(hicregion, c(-Inf, breaks, Inf), labels = cols)), nrow = nrow(hicregion))
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum & y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else if(y == 20){ #upside down triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y - 0.5, y)
} else {
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
ch
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
if(grepl("amazonaws", base)){
file <- paste(base, sample, "-", chromchr, ".rds", sep = "")
hicdata <- readRDS(gzcon(url(file)))
} else {
hicdata <- readRDS(base)
}
# Hacked Sushi HiC Plot Function
palette <- SushiColors(6)
rows <- as.numeric(rownames(hicdata))
cols <- as.numeric(colnames(hicdata))
hicregion <- as.matrix(hicdata[which(rows >= start & rows <= end), which(cols >= start & cols <= end)])
# determine number of bins
nbins <- nrow(hicregion)
stepsize <- abs(start - end)/(2 * nbins)
max_z <- max(hicregion, na.rm = TRUE)
min_z <- min(hicregion[hicregion > 0], na.rm = TRUE)
# map to colors
breaks <- seq(min_z, max_z, length.out = 100)
cols <- palette(length(breaks) + 1)
hicmcol <- matrix(as.character(cut(hicregion, c(-Inf, breaks, Inf), labels = cols)), nrow = nrow(hicregion))
# initialize plot
plot(1, 1, xlim = c(start, end), ylim = c(0, 20), type = "n", xaxs = "i", yaxs = "i",
bty = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = sample, adj = 0)
# fill plot
for (rownum in (1:nrow(hicregion))) {
y = -0.5
x = start + (rownum * 2 * stepsize) - (stepsize * 2)
for (colnum in (rownum:ncol(hicregion))) {
x = x + stepsize
y = y + 0.5
if(y <= 20){
if(colnum != rownum & y!=20){ # Square
xs = c(x - stepsize, x, x + stepsize, x, x - stepsize)
ys = c(y, y + 0.5, y, y - 0.5, y)
} else if(y == 20){ #upside down triangle
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y - 0.5, y)
} else {
xs = c(x - stepsize, x, x + stepsize)
ys = c(y, y + 0.5, y)
}
polygon(xs, ys, border = NA, col = hicmcol[colnum, rownum])
}
}
}
labelgenome(chromchr, start, end, n=4, scale="Mb",edgeblankfraction=0.20)
addlegend(c(min_z, max_z), palette = palette, title="", side="right",
bottominset=0.4, topinset=0, xoffset=-.035, labelside="left",
width=0.025, title.offset=0.035)
runApp()
packrat::init9)
packrat::snapshot9)
packrat::snapshot()
packrat::restore()
packrat::restore()
packrat::snapshot
packrat::snapshot()
packrat::snapshot()
packrat::restore9)
packrat::restore()
install.packages("gfortran")
install.packages("lgfortran")
install.packages("nlme")
packrat::init()
source("https://bioconductor.org/biocLite.R")
biocLite("limma")
biocLite("rtracklayer")
packrat::init()
install.packages("devtools")
devtools::install_github("aryeelab/diffloop")
library(diffloop)
shiny::runApp()
packrat::snapshot()
runApp()
library(tools)
library(shiny)
library(shinyBS)
library(shinythemes)
library(ggplot2)
library(GenomicRanges)
library(diffloop)
library(Sushi)
library(foreach)
library(rtracklayer)
library(DT)
library(grid)
library(readr)
library(bumphunter)
library(shinyFiles)
library(markdown)
library(knitr)
library(gsubfn)
library(RCurl)
library(Matrix)
library(dplyr)
library(edgeR)
library(rsconnect)
library(miniUI)
?diffloop::`diffloop-package`
runApp()
runApp()
i <- 5
chia_pet_samples <- list() #Tracks samples linking with i
chia_pet_objects <- c() #Tracks subsetted objects
j <- 1 #Index of subsetted objects vector
map_chia_pet.indices <- c() #maps i to order in vector of subsetted objects
mc <- 1 #max counts
one_anchor_samples <- list() #Tracks samples linking with i
file.conn <- dynamic.val$c.full[[i]]
g_h.c.full
file.conn <- "http://s3.amazonaws.com/dnalandscaper/data/human/loops/MCF7_1-POL2.rds"
if(grepl("amazonaws", file.conn)){ x <- readRDS(gzcon(url(file.conn)))
} else { x <- readRDS(file.conn) }
head(x)
sample <- names(dynamic.val$c.list)[i]
sample <- "dummy"
objReg <- removeSelfLoops(subsetRegion(x, dynamic.val$region))
chr1reg <- GRanges(seqnames=c("1"),ranges=IRanges(start=c(152583052),end=c(152614119)))
region <- chr1reg
objReg <- removeSelfLoops(subsetRegion(x, region))
oa <- try(one_anchor_samples[[which(map_chia_pet.indices == i)]], silent = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
region
region.bed <- import.bw(file, which = addchr(region))
g_h.m.bw.full
file <-  "http://s3.amazonaws.com/dnalandscaper/data/human/methylation/GM12878-wgbs.bw"
region.bed <- import.bw(file, which = addchr(region))
head(region.bed)
?tile
smoother <- 1000
region
tile <- tile(region, width = smoother)
head(tile)
str(tile)
?GRangesList
length(tile)
tile <- unlist(tile(region, width = smoother))
length(tile)
head(tile)
smoother
widths(tile)
width(tile)
?tile
?GRanges::tile
?GenomicRanges::tile
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(methyl.vals[sh])$score, qh, mean))
tile <- unlist(tile(region, width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(regions))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
values <- unname(ugly$bwvalues, force = TRUE)
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(region))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
values <- unname(ugly$bwvalues, force = TRUE)
values
head(region.bed)
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
dim(ugly)
length(values.t)
values.t
dim(values.t)
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(region))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
dim(ugly)
vNA
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
tile
region.bed <- tile
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
bumpplot <- recordPlot()
pos <- region.bedgraph$start
y <- region.bedgraph[,4]
cluster_id <- clusterMaker(chr=chrom, pos=pos, maxGap = 100)
smooth <- locfitByCluster(x=pos, y=y, cluster=cluster_id, bpSpan=50)
plot(pos, smooth$fitted, type="l", xaxt='n',bty = "n",xaxs="i",yaxs="i",main=sample,adj=0,ylab="")
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
# mtext(sample,side=2,line=2.5,cex=1,font=2)
if(shade) polygon(cbind(c(min(pos), pos, max(pos)), c(min(y), y, min(y))), border=NA, col="black")
plot.new()
?locfitByCluster
g_h.t.bw.full
file <- "http://s3.amazonaws.com/dnalandscaper/data/human/tracks/MCF7-CTCF.bw"
region.bed <- import.bw(file, which = addchr(region))
# smooth
if(smoother != 0){
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
region.bed <- tile
}
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
trackplot <- recordPlot()
plotBedgraph(region.bedgraph, chromchr, start, end,
main = sample, adj=0)
#mtext(ylab,side=2,line=2.5,cex=1,font=2)
axis(side=2,las=2,tcl=.2)
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
region.bed
tile[mcols(tile)$score != NA]
mcols(tile)$score
region.bed <- tile[!is.na(mcols(tile)$score)]
tile[!is.na(mcols(tile)$score)]
region.bed
region.bed <- import.bw(file, which = addchr(region))
# smooth
if(smoother != 0){
tile <- unlist(tile(addchr(region), width = smoother))
ovl <- findOverlaps(tile, region.bed)
qh <- queryHits(ovl)
sh <- subjectHits(ovl)
values.t <- as.data.frame(tapply(mcols(region.bed[sh])$score, qh, mean))
#A lot of extra effort to handle regions with no values
colnames(values.t) <- "bwvalues"
vNA <- data.frame(matrix(NA, ncol = 1, nrow = length(ranges(tile))))
colnames(vNA) <- "NAss"
ugly <- merge(vNA, values.t, by=0, all = TRUE, sort = F)
ugly <- ugly[order(as.numeric(ugly$Row.names)), ]
mcols(tile)$score <- unname(ugly$bwvalues, force = TRUE)
region.bed <- supressWarnings(tile[!is.na(mcols(tile)$score)])
}
region.bedgraph <- data.frame(region.bed)
region.bedgraph <- region.bedgraph[,c(-4,-5)]
if(log2) region.bedgraph$score <- log2(region.bedgraph$score)
chrom <- as.character(seqnames(region))
chromchr <- paste(c("chr", as.character(chrom)), collapse = "")
start <- as.integer(start(ranges(range(region))))
end <- as.integer(end(ranges(range(region))))
trackplot <- recordPlot()
plotBedgraph(region.bedgraph, chromchr, start, end,
main = sample, adj=0)
#mtext(ylab,side=2,line=2.5,cex=1,font=2)
axis(side=2,las=2,tcl=.2)
labelgenome(chromchr, start, end, side = 1, scipen = 20,
n = 3, scale = "Mb", line = 0.18, chromline = 0.5, scaleline = 0.5)
runApp()
?supressWarnings
runApp()
runApp()
runApp()
runApp()
